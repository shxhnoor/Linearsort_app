# Linear Search Visualization

To check that my Track and Field Linear search app worked efficiently and had met its requirements, I tested the I tested my Track and Field Linear Search app by using a range of inputs, including normal cases, worst-case, best-case and user input edge cases. I will also be providing video and picture evidence of every test below to clearly demonstrate accuracy of its algorithm, UI interaction, and functionality.  
# TEST CASES 
Normal case: 
The average case here is where the athlete one would be looking for is placed in the middle of the heat list. The program checks lanes before finding their name linearly, so it takes more steps than the best case but fewer steps than the worst case. 

Worst case:  
The worst case is where the runner is in the last lane or isn’t in the heat at all. The program has to go through every single lane before finding them or verifying they were missing. This scenario inevitably takes the longest, showing the maximum time the linear search algorithm can maintain. 

Best case: 
The best case here would be an instance where the runner is put in the very first lane of the heat. The program would find them immediately, so only one check is needed throughout the whole scenario. This is the fastest way as it shows how efficiently the algorithm works when the athletes name is at the beginning.
# Problem Breakdown
### Why I chose Linear Search:
I chose to implement and interpret linear search through a Track and Field-themed interactive app. The premise of the game is simple, as the user plays the role of a track coach preparing his heat for a big race. In order to prepare for the race, the coach must type the name of the runner they want to find in the heat, and the name is saved and used throughout the duration of the app to find themselves. As the search begins, the app randomly generates a heat of eight world-class sprinters. Each athlete is showcased inside of a lane box that includes an index number, lane number, and the athlete’s name. The lane assignments are stored internally in a Python list. Also, there is a controlled probability rate that the runner on the coach is searching for may or may not even appear in the heat list. This ensures that the program I built can demonstrate both possible outcomes of linear search, as the target could be or could not be found. 

When this project was first assigned to me, I immediately wanted to do something related to hobby of mine, which is competitive track and field. Initially, I did not know how to create a program that would relate to anything of the project, but then I had thought of heat lists and how it would suit perfectly for this project. I believe that linear search is the perfect algorithm for this project because the heat is unsorted, and lane assignments in real races are not alphabetically ordered by name. Using a more advanced algorithm like binary search would be unrealistic because heat lane is not sorted in a way that allows binary splitting. Linear search, on the other hand, directly shows what any coach would do: look at each lane, check the name, and move on to the next. 

This algorithm is ideal for teaching coding beginners because its logic is pretty self-explanatory. It allows users to move step-by-step through each of the athlete's names, which accurately shows how linear search would perform in best case scenarios, worst case scenarios, and not found cases. Linear search keeps its focus on clarification and its visualization, more complex search algorithms would be redundant in terms of difficulty and would not align with the objective of the app.  
### Decomposition
I began by breaking down the project's objective into smaller and manageable tasks. First, I knew the program accepts the name of the runner the user/coach wants to find on the list. Next, the app will generate a heat of runners randomly by choosing eight names from an already defined list and storing them inside a list of strings. Due to the list already being unsorted, the target runner could appear in any lane or might not appear at all, which creates average, best- and worst-case scenarios. Next, the program shows the heat visually using a GUI (gradio), where each lane is shown in a box styled by HTML. After the heat is shown, the linear search will begin at index 0, and each time the user presses the “Next Lane :)” button, the program checks the next athlete in sequence which them updates the display to show the current lane being checked, the previously checked lanes, and if found, the lane where the target appears. Finally, the search stops either when the athlete is found or when all eight lanes have been checked. 
