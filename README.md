# Linear Search Visualization

To check that my Track and Field Linear search app worked efficiently and had met its requirements, I tested the I tested my Track and Field Linear Search app by using a range of inputs, including normal cases, worst-case, best-case and user input edge cases. I will also be providing video and picture evidence of every test below to clearly demonstrate accuracy of its algorithm, UI interaction, and functionality.  
# TEST CASES 
Normal case: 

The average case here is where the athlete one would be looking for is placed in the middle of the heat list. The program checks lanes before finding their name linearly, so it takes more steps than the best case but fewer steps than the worst case. 

Worst case:  

The worst case is where the runner is in the last lane or isn’t in the heat at all. The program has to go through every single lane before finding them or verifying they were missing. This scenario inevitably takes the longest, showing the maximum time the linear search algorithm can maintain. 

Best case: 
[https://drive.google.com/file/d/1c4XFr9RVoxXZH-mi3NUe2o_0y30eFqa_/view?usp=drive_link](url)

The best case here would be an instance where the runner is put in the very first lane of the heat. The program would find them immediately, so only one check is needed throughout the whole scenario. This is the fastest way as it shows how efficiently the algorithm works when the athletes name is at the beginning.
# Problem Breakdown
### Why I chose Linear Search:
I chose to implement and interpret Linear Search through a Track and Field-themed interactive app. The premise of the game is simple, as the user plays the role of a track coach preparing his heat for a big race. In order to prepare for the race, the coach must type the name of the runner they want to find in the heat, and the name is saved and used throughout the duration of the app to find themselves. As the search begins, the app randomly generates a heat of eight world-class sprinters. Each athlete is showcased inside of a lane box that includes an index number, lane number, and the athlete’s name. The lane assignments are stored internally in a Python list. Also, there is a controlled probability rate that the runner on the coach is searching for may or may not even appear in the heat list. This ensures that the program I built can demonstrate both possible outcomes of Linear Search, as the target could be or could not be found. 

When this project was first assigned to me, I immediately wanted to do something related to hobby of mine, which is competitive track and field. Initially, I did not know how to create a program that would relate to anything of the project, but then I had thought of heat lists and how it would suit perfectly for this project. I believe that Linear Search is the perfect algorithm for this project because the heat is unsorted, and lane assignments in real races are not alphabetically ordered by name. Using a more advanced algorithm like binary search would be unrealistic because heat lane is not sorted in a way that allows binary splitting. Linear Search, on the other hand, directly shows what any coach would do: look at each lane, check the name, and move on to the next. 

This algorithm is ideal for teaching coding beginners because its logic is pretty self-explanatory. It allows users to move step-by-step through each of the athlete's names, which accurately shows how linear search would perform in best case scenarios, worst case scenarios, and not found cases. Linear Search keeps its focus on clarification and its visualization, more complex search algorithms would be redundant in terms of difficulty and would not align with the objective of the app.  
### Decomposition
I began by breaking down the project's objective into smaller and manageable tasks. First, I knew the program accepts the name of the runner the user/coach wants to find on the list. Next, the app will generate a heat of runners randomly by choosing eight names from an already defined list and storing them inside a list of strings. Due to the list already being unsorted, the target runner could appear in any lane or might not appear at all, which creates average, best- and worst-case scenarios. Next, the program shows the heat visually using a GUI (gradio), where each lane is shown in a box styled by HTML. After the heat is shown, the linear search will begin at index 0, and each time the user presses the “Next Lane :)” button, the program checks the next athlete in sequence which them updates the display to show the current lane being checked, the previously checked lanes, and if found, the lane where the target appears. Finally, the search stops either when the athlete is found or when all eight lanes have been checked. 
### Pattern Recognition
One thing I noticed was that Linear Search works by repeating the same process for every element in a list, and this repetition and predictability becomes especially clear in a scenario with lanes/races. The algorithm checks the current lane, compares the athlete’s name to the target runner, and then either stops or moves to the next lane. This same action will then be repeated for each index in the list. In the interface, this repetition is shown visually through consistent lane states, so the current lane turns yellow to indicate it is being examined, previously checked lanes turn grey to show they have already been processed, and the lane containing the target runner turns green when a match is found. This repeated sequence of comparing and advancement ends up allowing the user to understand the basic structure of the algorithm. 
### Abstraction 
In terms of abstraction, I wanted to make sure the program was simple to understand, so it was created to hide any internal mechanisms and present only the parts that help demonstrate Linear Search. Thus, anyone using the program will not see the python list, the randomization of names, or any bookkeeping with variables controlling the search. The use would instead be interacting with the lanes, names, and updates in the app. The abstraction gets rid of details that are redundant for understanding the logic behind Linear Search, and mainly focuses on the lanes, progress indicators, and the messages that explain what the algorithm is doing at each step. 
### Algorithm Design
When speaking of algorithmic design, the flow of the algorithm makes a gradual progression. The input in this case would be the runner’s name that is given by the user as a string. The program will process the input by creating a randomized eight-lane heat shown as a list of strings, and the algorithm will then go through the list one element at the time when the search begins, comparing the target’s name with the runner in the current lane. After the comparisons, the GUI will then update by highlighting the lane that is being checked, and while this is all happening, the progress bar will be updated as well. Lastly, the output will essentially depend on the result of the comparisons. For example, if the target runner has been found, the lane lumber would then be shown with a message saying “FOUND!”. If the search reaches the end without a match, the app will then report that the runner is not in the heat. To preface, everything is shown visually through the Gradio interface, which makes the algorithm pretty simple to follow. 
